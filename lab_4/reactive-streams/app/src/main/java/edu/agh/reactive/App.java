/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.agh.reactive;

import akka.Done;
import akka.NotUsed;
import akka.actor.typed.ActorSystem;
import akka.actor.typed.javadsl.Behaviors;
import akka.japi.Pair;
import akka.stream.*;
import akka.stream.javadsl.*;
import edu.agh.reactive.hello.HelloActor;
import edu.agh.reactive.math.MathActor;

import java.io.IOException;
import java.util.concurrent.CompletionStage;

public class App {
    public static void main(String[] args) throws InterruptedException {
        final ActorSystem streamSystem = ActorSystem.create(Behaviors.empty(), "streams");
        final Materializer materializer = Materializer.createMaterializer(streamSystem);

        // Task 1
//        sendMsg();

        // Task 2 - backpressure
//        backpressure(materializer);

        // TASK 3 - graph dsl
        graphDSL(materializer);

        try {
            System.out.println(">>> Press ENTER to exit <<<");
            System.in.read();
        } catch (IOException ignored) {
        } finally {
//            greeterMain.terminate();
//            mathContext.terminate();
//            helloSystem.terminate();
//            streamSystem.terminate();
        }
    }

    private static void sendMsg() {
        final ActorSystem<String> helloSystem = ActorSystem.create(HelloActor.create(), "helloActor");

        // send example message
        helloSystem.tell("hello world");

        final ActorSystem<MathActor.MathCommand> mathContext = ActorSystem.create(MathActor.create(), "actorMath");
        System.out.println("math main: actor system ready");

        // send messages
        mathContext.tell(new MathActor.MathCommandAdd(5, 3));
        mathContext.tell(new MathActor.MathCommandMultiply(5, 3, null));
        mathContext.tell(new MathActor.MathCommandMultiply(5, 2, null));
        mathContext.tell(new MathActor.MathCommandDivide(15, 3, null));
        mathContext.tell(new MathActor.MathCommandDivide(15, 5, null));

        mathContext.tell(new MathActor.MathCommandDivide(15, 0, null));
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Math main: sending second package of messages");
        mathContext.tell(new MathActor.MathCommandMultiply(5, 3, null));
        mathContext.tell(new MathActor.MathCommandMultiply(5, 2, null));
        mathContext.tell(new MathActor.MathCommandDivide(15, 3, null));
        mathContext.tell(new MathActor.MathCommandDivide(15, 5, null));
        System.out.println("Math main: messages send");
    }

    private static void backpressure(Materializer materializer) {
        final Source<Integer, NotUsed> source = Source.range(1, 100);

        final Sink<String, CompletionStage<Done>> slowSink = Sink.foreach(str-> {
            try {
                Thread.sleep(1000);
                System.out.println("sink " + str);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        final Flow<Integer, String, NotUsed> debuggingFlow = Flow.fromFunction(
                (Integer n) -> {
                    System.out.println("_flow " + n.toString());
                    return n.toString();
            });

        // BACK PRESSURE
        // If the buffer is full when a new element is available this strategy backpressures the upstream publisher until space becomes available in the buffer.
//        final RunnableGraph<NotUsed> runnableGraph = source.via(debuggingFlow).buffer(7, OverflowStrategy.backpressure()).async().to(slowSink);

        // DROP TAIL
        // If the buffer is full when a new element arrives, drops the youngest element from the buffer to make space for the new element
        final RunnableGraph<NotUsed> runnableGraph = source.via(debuggingFlow).buffer(7, OverflowStrategy.dropTail()).async().to(slowSink);

        // DROP HEAD
        // If the buffer is full when a new element arrives, drops the oldest element from the buffer to make space for the new element.
//        final RunnableGraph<NotUsed> runnableGraph = source.via(debuggingFlow).buffer(7, OverflowStrategy.dropHead()).async().to(slowSink);

        // FAIL
        // If the buffer is full when a new element is available this strategy completes the stream with failure
//        final RunnableGraph<NotUsed> runnableGraph = source.via(debuggingFlow).buffer(7, OverflowStrategy.fail()).async().to(slowSink);

        runnableGraph.run(materializer);
    }

    private static void graphDSL(Materializer materializer) throws InterruptedException {
        final Source<Integer, NotUsed> dslInput = Source.range(1, 100);

        final Sink<Pair<Integer, Integer>, CompletionStage<Done>> dslSink = Sink.foreach(System.out::println);

        final Flow<Integer, Integer, NotUsed> addFlow = Flow.of(Integer.class).map(integer -> integer + 1);
        final Flow<Integer, Integer, NotUsed> multiFlow = Flow.of(Integer.class).map(integer -> integer * 10);

        // dsl graph
        final Graph<ClosedShape, CompletionStage<Done>> graph = GraphDSL.create(dslSink, (builder, out) -> {
            final UniformFanOutShape<Integer, Integer> bcast = builder.add(Broadcast.create(2));
            final FanInShape2<Integer, Integer, Pair<Integer, Integer>> zip = builder.add(Zip.create());
            final Outlet<Integer> source = builder.add(dslInput).out();

            builder.from(source).toFanOut(bcast);
            builder.from(bcast).via(builder.add(addFlow)).toInlet(zip.in0());
            builder.from(bcast).via(builder.add(multiFlow)).toInlet(zip.in1());
            builder.from(zip.out()).to(out);

            return ClosedShape.getInstance();
        });

        RunnableGraph.fromGraph(graph).run(materializer);
    }
}
